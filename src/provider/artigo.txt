FONTE https://dev.to/sanjayttg/jwt-authentication-in-react-with-react-router-1d03

Criando o AuthProvider e o AuthContext no React
Com nosso projeto configurado e dependências instaladas, estamos prontos para dar o próximo passo na implementação da autenticação JWT. Nesta seção, criaremos um AuthProvidercomponente e um AuthContext. Isso nos permitirá armazenar e compartilhar dados e funções relacionados à autenticação em todo o nosso aplicativo

No trecho de código a seguir, criaremos o authProvider.jsarquivo localizado em src > provider > authProvider.js. Vamos explorar a implementação do AuthProviderand AuthContext.

Importe os módulos e pacotes necessários:

axios é importado do pacote "axios" para lidar com solicitações de API.
createContext, useContext, useEffect, useMemo e useState são importados da biblioteca "react".
import axios from "axios";
import {
  createContext,
  useContext,
  useEffect,
  useMemo,
  useState,
} from "react";
Crie um contexto de autenticação usando createContext():

createContext() cria um objeto de contexto vazio que será usado para compartilhar o estado de autenticação e as funções entre os componentes.
const AuthContext = createContext();
Crie o componente AuthProvider:

Este componente serve como provedor para o contexto de autenticação.
Ele recebe filhos como uma propriedade, que representa os componentes filhos que terão acesso ao contexto de autenticação.
const AuthProvider = ({ children }) => {
  // Component content goes here
};
Defina o tokenestado usando useState():

tokenrepresenta o token de autenticação.
localStorage.getItem("token")recupera o valor do token do armazenamento local, se existir.
const [token, setToken_] = useState(localStorage.getItem("token"));
Crie a setTokenfunção para atualizar o token de autenticação:

Esta função é usada para definir o novo valor do token.
Ele atualiza o tokenestado usando setToken_()e armazena o valor do token no armazenamento local usando localStorage.setItem().
const setToken = (newToken) => {
  setToken_(newToken);
};
Use useEffect()para definir o cabeçalho de autorização padrão no axios e armazenar o valor do token no armazenamento local usando localStorage.setItem():

Este efeito é executado sempre que o tokenvalor muda.
Se tokenexistir, ele define o cabeçalho de autorização em axios e localStorage.
Se tokenfor nulo ou indefinido, ele remove o cabeçalho de autorização de axios e localStorage.
useEffect(() => {
  if (token) {
    axios.defaults.headers.common["Authorization"] = "Bearer " + token;
    localStorage.setItem('token',token);
  } else {
    delete axios.defaults.headers.common["Authorization"];
    localStorage.removeItem('token')
  }
}, [token]);
Crie o valor de contexto memorizado usando useMemo():

O valor de contexto inclui o token e a função setToken.
O valor do token é usado como uma dependência para memorização.
const contextValue = useMemo(
  () => ({
    token,
    setToken,
  }),
  [token]
);
Forneça o contexto de autenticação para os componentes filhos:

Envolva os componentes filhos com o AuthContext.Provider.
Passe o contextValue como a propriedade value do provedor.
return (
  <AuthContext.Provider value={contextValue}>
    {children}
  </AuthContext.Provider>
);
Exporte o gancho useAuth para acessar o contexto de autenticação:

useAuth é um hook personalizado que pode ser usado em componentes para acessar o contexto de autenticação.
export const useAuth = () => {
  return useContext(AuthContext);
};
Exporte o componente AuthProvider como a exportação padrão:

Isso permite que outros arquivos sejam importados e usem o componente AuthProvider conforme necessário.
export default AuthProvider;
Código completo:

import axios from "axios";
import { createContext, useContext, useEffect, useMemo, useState } from "react";

const AuthContext = createContext();

const AuthProvider = ({ children }) => {
  // State to hold the authentication token
  const [token, setToken_] = useState(localStorage.getItem("token"));

  // Function to set the authentication token
  const setToken = (newToken) => {
    setToken_(newToken);
  };

  useEffect(() => {
    if (token) {
      axios.defaults.headers.common["Authorization"] = "Bearer " + token;
      localStorage.setItem('token',token);
    } else {
      delete axios.defaults.headers.common["Authorization"];
      localStorage.removeItem('token')
    }
  }, [token]);

  // Memoized value of the authentication context
  const contextValue = useMemo(
    () => ({
      token,
      setToken,
    }),
    [token]
  );

  // Provide the authentication context to the children components
  return (
    <AuthContext.Provider value={contextValue}>{children}</AuthContext.Provider>
  );
};

export const useAuth = () => {
  return useContext(AuthContext);
};

export default AuthProvider;
Em resumo, este código configura o contexto de autenticação usando a API de contexto do React. Ele fornece o token de autenticação e a função setToken para componentes filhos por meio do contexto. Ele também garante que o cabeçalho de autorização padrão no axios seja atualizado com o token de autenticação sempre que ele for alterado.

Criando rotas no React para autenticação JWT
Para organizar nossas rotas efetivamente, criaremos uma src > routespasta dedicada. Dentro dessa pasta, criaremos um index.jsxarquivo, que servirá como ponto de entrada para definir as rotas do nosso aplicativo. Ao estruturar nossas rotas em uma pasta separada, podemos manter uma estrutura de roteamento clara e gerenciável. Vamos prosseguir com a criação de nossas rotas e explorar como podemos incorporar a autenticação JWT em nosso aplicativo React.

Criando um componente ProtectedRoute para rotas autenticadas

Para proteger nossas rotas autenticadas e impedir acesso não autorizado, criaremos um componente dedicado chamado ProtectedRoute. Este componente servirá como um wrapper para nossas rotas autenticadas, garantindo que apenas usuários autenticados possam acessá-las. Ao implementar este componente, podemos facilmente impor requisitos de autenticação e fornecer uma experiência de usuário perfeita. Vamos criar o ProtectedRoute.jsxarquivo localizado em src > routes > ProtectedRoute.jsxe aprimorar a segurança do nosso aplicativo.

Começamos importando as dependências necessárias da biblioteca react-router-dom:

import { Navigate, Outlet } from "react-router-dom";
import { useAuth } from "../provider/authProvider";
Definimos o componente ProtectedRoute, que servirá como um wrapper para nossas rotas autenticadas:

export const ProtectedRoute = () => {
  const { token } = useAuth();

  // Check if the user is authenticated
  if (!token) {
    // If not authenticated, redirect to the login page
    return <Navigate to="/login" />;
  }

  // If authenticated, render the child routes
  return <Outlet />;
};
Dentro do componente ProtectedRoute, acessamos o token do hook personalizado useAuth fornecido pelo AuthContext. Esse hook nos permite recuperar o token de autenticação armazenado no contexto.

Em seguida, verificamos se o token existe. Se o usuário não estiver autenticado (o token é falso ou nulo), usamos o componente Navigate do react-router-dom para redirecionar o usuário para a página de login ("/login").

Se o usuário for autenticado, renderizamos as rotas filhas usando o componente Outlet. O componente Outlet atua como um placeholder que exibe os componentes filhos definidos na rota pai.

Em resumo, o componente ProtectedRoute serve como um guarda para rotas autenticadas. Se o usuário não for autenticado, ele será redirecionado para a página de login. Se o usuário for autenticado, as rotas filhas definidas dentro do componente ProtectedRoute serão renderizadas usando o componente Outlet.

Este código nos permite proteger facilmente rotas específicas e controlar o acesso com base no status de autenticação do usuário, proporcionando uma experiência de navegação segura em nosso aplicativo React.

Mergulho profundo em Rotas
Agora que temos nosso ProtectedRoutecomponente e contexto de autenticação em vigor, podemos prosseguir com a definição de nossas rotas. Ao diferenciar entre rotas públicas, rotas autenticadas e rotas para usuários não autenticados, podemos efetivamente lidar com navegação e controle de acesso com base na autenticação JWT. Neste trecho de código, vamos mergulhar no src > routes > index.jsxarquivo e explorar como podemos incorporar a autenticação JWT em nossa estrutura de roteamento. Vamos começar!

Importe as dependências necessárias:

RouterProvider e createBrowserRouter são componentes importados da biblioteca react-router-dom. Eles são usados ​​para configurar e fornecer a funcionalidade de roteamento.
useAuth é um hook personalizado importado de "../provider/authProvider". Ele nos permite acessar o contexto de autenticação.
ProtectedRoute é um componente importado de "./ProtectedRoute". Ele serve como um wrapper para rotas autenticadas.
import { RouterProvider, createBrowserRouter } from "react-router-dom";
import { useAuth } from "../provider/authProvider";
import { ProtectedRoute } from "./ProtectedRoute";
Defina o componente Rotas:

Este componente funcional atua como ponto de entrada para configurar as rotas do aplicativo.
const Routes = () => {
  const { token } = useAuth();
  // Route configurations go here
};
Acesse o token de autenticação usando o gancho useAuth:

O hook useAuth é chamado para recuperar o valor do token do contexto de autenticação. Ele nos permite acessar o token de autenticação dentro do componente Routes.
const { token } = useAuth();
Defina rotas acessíveis a todos os usuários:

O array routesForPublic contém objetos de rota que podem ser acessados ​​por todos os usuários. Cada objeto de rota consiste em um caminho e um elemento.
A propriedade path especifica o caminho da URL para a rota, e a propriedade element contém o elemento/componente JSX a ser renderizado.
const routesForPublic = [
  {
    path: "/service",
    element: <div>Service Page</div>,
  },
  {
    path: "/about-us",
    element: <div>About Us</div>,
  },
];
Defina rotas acessíveis apenas a usuários autenticados:

O array routesForAuthenticatedOnly contém objetos de rota que podem ser acessados ​​somente por usuários autenticados. Ele inclui uma rota raiz protegida ("/") encapsulada no componente ProtectedRoute e rotas filhas adicionais definidas usando a propriedade children.
const routesForAuthenticatedOnly = [
  {
    path: "/",
    element: <ProtectedRoute />,
    children: [
      {
        path: "/",
        element: <div>User Home Page</div>,
      },
      {
        path: "/profile",
        element: <div>User Profile</div>,
      },
      {
        path: "/logout",
        element: <div>Logout</div>,
      },
    ],
  },
];
Defina rotas acessíveis somente a usuários não autenticados:

O array routesForNotAuthenticatedOnly contém objetos de rota que são acessíveis somente a usuários não autenticados. Ele inclui uma rota de login ("/login").
const routesForNotAuthenticatedOnly = [
  {
    path: "/",
    element: <div>Home Page</div>,
  },
  {
    path: "/login",
    element: <div>Login</div>,
  },
];
Combine e inclua rotas condicionalmente com base no status de autenticação:

A função createBrowserRouter é usada para criar a configuração do roteador. Ela recebe um array de rotas como argumento.
O operador de propagação (...) é usado para mesclar as matrizes de rotas em uma única matriz.
A expressão condicional (!token ? routesForNotAuthenticatedOnly : []) verifica se o usuário está autenticado (o token existe). Caso contrário, inclui o array routesForNotAuthenticatedOnly; caso contrário, inclui um array vazio.
const router = createBrowserRouter([
  ...routesForPublic,
  ...(!token ? routesForNotAuthenticatedOnly : []),
  ...routesForAuthenticatedOnly,
]);
Forneça a configuração do roteador usando RouterProvider:

O componente RouterProvider encapsula a configuração do roteador, tornando-a disponível para todo o aplicativo.
return <RouterProvider router={router} />;
Código completo:

import { RouterProvider, createBrowserRouter } from "react-router-dom";
import { useAuth } from "../provider/authProvider";
import { ProtectedRoute } from "./ProtectedRoute";

const Routes = () => {
  const { token } = useAuth();

  // Define public routes accessible to all users
  const routesForPublic = [
    {
      path: "/service",
      element: <div>Service Page</div>,
    },
    {
      path: "/about-us",
      element: <div>About Us</div>,
    },
  ];

  // Define routes accessible only to authenticated users
  const routesForAuthenticatedOnly = [
    {
      path: "/",
      element: <ProtectedRoute />, // Wrap the component in ProtectedRoute
      children: [
        {
          path: "/",
          element: <div>User Home Page</div>,
        },
        {
          path: "/profile",
          element: <div>User Profile</div>,
        },
        {
          path: "/logout",
          element: <div>Logout</div>,
        },
      ],
    },
  ];

  // Define routes accessible only to non-authenticated users
  const routesForNotAuthenticatedOnly = [
    {
      path: "/",
      element: <div>Home Page</div>,
    },
    {
      path: "/login",
      element: <div>Login</div>,
    },
  ];

  // Combine and conditionally include routes based on authentication status
  const router = createBrowserRouter([
    ...routesForPublic,
    ...(!token ? routesForNotAuthenticatedOnly : []),
    ...routesForAuthenticatedOnly,
  ]);

  // Provide the router configuration using RouterProvider
  return <RouterProvider router={router} />;
};

export default Routes;
Integração final
Agora que temos nosso AuthContext, AuthProvidere Routespronto, vamos integrá-los em App.jsx.

Importe os componentes e arquivos necessários:

AuthProvideré um componente importado de "./provider/authProvider". Ele fornece o contexto de autenticação para o aplicativo.
Routesé um componente importado de "./routes". Ele define as rotas do aplicativo.
import AuthProvider from "./provider/authProvider";
import Routes from "./routes";
Envolva o Routescomponente com o AuthProvidercomponente:

O AuthProvidercomponente é usado para fornecer o contexto de autenticação para o aplicativo. Ele envolve o Routescomponente para tornar o contexto de autenticação disponível para todos os componentes dentro da Routesárvore de componentes.
return (
  <AuthProvider>
    <Routes />
  </AuthProvider>
);
Código completo:

import AuthProvider from "./provider/authProvider";
import Routes from "./routes";

function App() {
  return (
    <AuthProvider>
      <Routes />
    </AuthProvider>
  );
}

export default App;
Agora que tudo está no lugar, é hora de implementar Logine Logout.
Vamos criar um arquivo para a página de login src > pages > Login.jsx
Página de login

const Login = () => {
  const { setToken } = useAuth();
  const navigate = useNavigate();

  const handleLogin = () => {
    setToken("this is a test token");
    navigate("/", { replace: true });
  };

  setTimeout(() => {
    handleLogin();
  }, 3 * 1000);

  return <>Login Page</>;
};

export default Login;
O componente Login é um componente funcional que representa a página de login.
Ele importa a função setToken do contexto de autenticação usando o gancho useAuth.
A função de navegação da biblioteca react-router-dom é importada para manipular a navegação.
Dentro do componente, há uma função handleLogin que define um token de teste usando a função setToken do contexto e navega até a página inicial ("/") com a opção replace definida como true.
Uma função setTimeout é usada para simular um atraso de 3 segundos antes de chamar a função handleLogin.
O componente retorna o JSX para a página de login, que neste caso é um texto de espaço reservado.
Agora criaremos um arquivo para a página src > pages > Logout.jsx
de logout .

import { useNavigate } from "react-router-dom";
import { useAuth } from "../provider/authProvider";

const Logout = () => {
  const { setToken } = useAuth();
  const navigate = useNavigate();

  const handleLogout = () => {
    setToken();
    navigate("/", { replace: true });
  };

  setTimeout(() => {
    handleLogout();
  }, 3 * 1000);

  return <>Logout Page</>;
};

export default Logout;
No componente Logout, chamamos setTokena função sem argumentos, com é igual a setToken(null).
Agora, substituiremos os componentes Login e Logout existentes no componente Rotas pelas versões atualizadas.

const routesForNotAuthenticatedOnly = [
  {
    path: "/",
    element: <div>Home Page</div>,
  },
  {
    path: "/login",
    element: <Login />,
  },
];
Na routesForNotAuthenticatedOnlymatriz, a elementpropriedade de "/login"é definida como <Login />, o que significa que o Logincomponente será renderizado quando o usuário visitar o caminho "/login".

const routesForAuthenticatedOnly = [
  {
    path: "/",
    element: <ProtectedRoute />, // Wrap the component in ProtectedRoute
    children: [
      {
        path: "/",
        element: <div>User Home Page</div>,
      },
      {
        path: "/profile",
        element: <div>User Profile</div>,
      },
      {
        path: "/logout",
        element: <Logout />,
      },
    ],
  },
];
Na routesForAuthenticatedOnlymatriz, a elementpropriedade de "/logout"é definida como <Logout />, o que significa que o componente Logout será renderizado quando o usuário visitar o caminho "/logout".

Fluxo de teste

Quando você visitar a página raiz pela primeira vez /, verá a "Página inicial" do routesForNotAuthenticatedOnlyarray.
Se você navegar para /login, após um atraso de 3 segundos, o processo de login será simulado. Ele definirá um token de teste usando a setTokenfunção do contexto de autenticação e, em seguida, você será redirecionado para a página raiz /usando a navigatefunção da react-router-dombiblioteca. Após o redirecionamento, você verá a "User Home Page" do routesForAuthenticatedOnlyarray.
Se você visitar /logout, depois de um atraso de 3 segundos, o processo de logout será simulado. Ele limpará o token de autenticação chamando a setTokenfunção sem nenhum argumento, e então você será redirecionado para a página raiz /novamente. Como você está desconectado, veremos a "Home Page" do routesForNotAuthenticatedOnlyarray.
Este fluxo demonstra os processos de login e logout, onde o usuário transita entre estados autenticado e não autenticado e as rotas correspondentes são exibidas adequadamente.